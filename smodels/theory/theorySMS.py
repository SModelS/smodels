"""
.. module:: tree
   :synopsis: This is a class for describing Simplified Model Topologies
              used for decomposing BSM models.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>

"""


from smodels.theory.exceptions import SModelSTheoryError as SModelSError
from smodels.tools.genericSMS import GenericSMS
from smodels.theory import crossSection
from itertools import product
from smodels.tools.physicsUnits import fb

class TheorySMS(GenericSMS):
    """
    A class for describing Simplified Model Topologies generated by the decompostion
    of full BSM models.
    """

    def __init__(self):
        """
        Initialize basic attributes.
        """

        GenericSMS.__init__(self)

        # Include additional attributes
        self._maxWeight = None
        self._sorted = False
        self.weightList = crossSection.XSectionList()
        # List of SMS topologies which could have generated self (such as during compression)
        self.parents = [self]
        self.smsID = 0  # SMS identifier
        # Type of analyses which have SMS matching self:
        self.coveredBy = set()
        # Type of analyses which have SMS matching self and for
        # which the physical parameters are covered
        self.testedBy = set()

    def __add__(self, other):
        """
        Combines the equivalent nodes (add particles).
        Can only be done if self and other have the same topology and ordering.

        :param other: TheorySMS object

        :return: new SMS with the combined particles (TheorySMS object)
        """

        return self.addNodesFrom(other)

    def copy(self):
        """
        Returns a shallow copy of self.

        : return: TheorySMS object
        """

        newSMS = TheorySMS()
        newSMS._successors.update({n: daughters[:]
                                       for n, daughters in self._successors.items()})
        newSMS._predecessors = {k: v for k, v in self._predecessors.items()}
        newSMS._nodesMapping = {n: node for n, node in self.nodesMapping.items()}
        newSMS._rootIndex = self._rootIndex
        newSMS._canonName = self._canonName
        newSMS._maxWeight = self._maxWeight
        newSMS._sorted = self._sorted
        newSMS.weightList = self.weightList.copy()
        newSMS.parents = self.parents[:]
        newSMS.smsID = self.smsID
        newSMS.coveredBy = set(list(self.coveredBy)[:])
        newSMS.testedBy = set(list(self.testedBy)[:])

        return newSMS

    def addNodesFrom(self, other):
        """
        Combines the nodes (add particles) in equivalent nodes in each trees.
        Can only be done if the trees have the same topology and ordering.

        : param other: TheorySMS object

        : return: new SMS with the combined particles(Tree object)
        """

        if other.canonName != self.canonName:
            raise SModelSError("Can not add trees with distinct topologies")

        nodesB = other.nodes
        newMapping = {}
        for n in self.nodeIndices:
            newMapping[n] = self.indexToNode(n) + other.indexToNode(n)


        newSMS = self.copy()
        # Just change the nodeIndex -> node mapping:
        newSMS.relabelNodes(nodeObjectDict=newMapping)

        return newSMS

    def attachDecay(self, motherIndex, decayNodes, copy=True):
        """
        Attaches a decay to self. If copy = True, returns a copy of self
        with the decay attached.

        : param decay: A tuple containing the mother node (carring the BR as the nodeWeight)
                      and the daughter nodes.

        : param copy: if True, return a copy of self, with the decay attached.

        : return: new tree with the other composed with self.
        """

        motherNode = decayNodes[0]
        daughterNodes = decayNodes[1]

        if copy:
            newSMS = self.copy()
        else:
            newSMS = self

        oldMother = self.indexToNode(motherIndex)
        # Update maximum weight
        if newSMS._maxWeight:
            oldMotherWeight = oldMother.nodeWeight
            if oldMotherWeight:
                newSMS._maxWeight = newSMS._maxWeight/oldMotherWeight
            newSMS._maxWeight = newSMS._maxWeight*motherNode.nodeWeight

        # Update mother node:
        self.updateNodeObjects({motherIndex : motherNode})
        # Add daughter nodes and edges:
        for d in daughterNodes:
            dIndex = self.add_node(d)
            newSMS.add_edge(motherIndex, dIndex)

        # The tree is no longer sorted
        newSMS._sorted = False

        return newSMS

    def getFinalStates(self, nodeIndex=None):
        """
        Get the list of particles which have not decayed (appear at the top of the tree).
        If nodeIndex is defined, get the final states generated by the cascade decay of the corresponding node. It also sets the finalState attribute for the node.

        :param nodeIndex: Node index for which to get the final states.

        :returns: list of Particle objects
        """

        if nodeIndex is None:
            nodeIndex = self.rootIndex

        node = self.indexToNode(nodeIndex)
        if node.finalStates is not None:
            return node.finalStates

        # For leaves, the final state is themselves:
        if self.out_degree(nodeIndex) == 0:
            finalStates = [node.particle]
        else:
            finalStates = []
            for dIndex in self.daughterIndices(nodeIndex):
                finalStates += self.getFinalStates(dIndex)

        # Set final state attribute for node:
        node.finalStates = sorted(finalStates)

        return node.finalStates

    def getWeightList(self):
        """
        Computes the SMS weight (production cross-section*BRs).
        It does not include the weight of final state (undecayed) particles.

        :return: CrossSectionList object
        """

        root = self.root
        prodXSec = root.nodeWeight
        maxXSec = prodXSec.getMaxXsec().asNumber(fb)
        maxWeight = self.getMaxWeight()
        brs = maxWeight/maxXSec
        weightList = prodXSec*brs

        return weightList

    def getMaxWeight(self):
        """
        Computes the SMS maximum weight (max production cross-section*BRs).
        Does not include the weight of final state (undecayed) particles.

        :return: SMS weight in fb (float).
        """

        if self._maxWeight is not None:
            return self._maxWeight

        # Get maximum production cross-section
        root = self.root
        prodXSec = root.nodeWeight
        maxXsec = prodXSec.getMaxXsec().asNumber(fb)

        # Get product of branching ratios:
        brs = 1.0
        for nodeIndex in self.nodeIndices:
            if nodeIndex == self.rootIndex:
                continue
            if self.out_degree(nodeIndex) == 0:
                continue
            node = self.indexToNode(nodeIndex)
            brs *= node.nodeWeight

        weight = maxXsec*brs
        self._maxWeight = weight

        return self._maxWeight

    def compareTo(self, other, n1=None, n2=None):
        """
        Compare the subtrees from self and other generated by the nodes n1 and n2.

        :param other: TheorySMS object to be compared against self
        :param n1: Node index for the root of subtree1 from self
        :param n2: Node index for the root of subtree2 from other

        :return: 0, if subtrees are equal, -1 if subtree1 < subtree2, 1 if subtree1 > subtree2
        """

        if not isinstance(other,TheorySMS):
            raise SModelSError("Can not compare TheorySMS and %s" %str(type(other)))

        # Make sure the SMS are sorted
        # (if it has already been sorted, it does nothing)
        if n1 is None:
            self.sort()
        if n2 is None:
            other.sort()

        if n1 is None:
            n1 = self.rootIndex
        if n2 is None:
            n2 = other.rootIndex

        # Get root node objects
        root1 = self.indexToNode(n1)
        root2 = other.indexToNode(n2)
        cmp = root1.compareTo(root2)
        if cmp != 0:
            return cmp

        # For inclusive nodes always return True (once nodes are equal)
        if root1.isInclusive or root2.isInclusive:
            return 0

        daughters1 = self.daughterIndices(n1)
        daughters2 = other.daughterIndices(n2)
        # If nodes are leaves, return 0
        if len(daughters1) == len(daughters2) == 0:
            return 0

        # Check if the daughters from root1 match the ones from root2:
        # (the daughters should be sorted at this point)
        for i1, d1 in enumerate(daughters1):
            d2 = daughters2[i1]
            cmp = self.compareTo(other, d1, d2)
            if cmp != 0:
                return cmp
        return 0

    def sort(self, nodeIndex=None, force=False):
        """
        Sort subtree of self generated by nodeIndex.
        If nodeIndex is None, sort the tree.
        If the self is already tagged as sorted and force = False,
        do nothing.

        : param nodeIndex: Node index
        : param force: If True, will sort even if self is tagged as sorted.
        """

        # If tree is already sorted, do nothing
        if self._sorted and not force:
            return

        if nodeIndex is None:
            cName = self.canonName  # Just to make sure canonName is defined
            if cName is None:
                return
            nodeIndex = self.rootIndex

        daughters = self.daughterIndices(nodeIndex)
        if daughters:
            for d in daughters:
                self.sort(d, force=force)
            sorted_daughters = self.sortSubTrees(daughters)


            # Remove nodeIndex -> daughters edges
            self.remove_edges(product([nodeIndex],daughters))
            # Add edges with the correct ordering:
            self.add_edges(product([nodeIndex],sorted_daughters))

        # Finally, after sorting the subtrees,
        # make sure the nodes are sorted according
        # to the generations (breadth-first search)
        if nodeIndex == self.rootIndex:
            self.bfs_sort()
            # Tag the tree as sorted
            self._sorted = True

    def sortSubTrees(self, subtreeList):
        """
        Sorts a list of subtrees of self generated by the nodes
        in subtreeList.

        : param subtreeList: List of node indices to be considered as roots
                            of the subtrees.

        : return: Sorted list of node indices.
        """

        if len(subtreeList) == 1 or len(subtreeList) == 0:
            return subtreeList

        # First group subtrees by their canonical name:
        nameDict = {}
        for nodeIndex in subtreeList:
            cName = self.indexToNode(nodeIndex).canonName
            if cName not in nameDict:
                nameDict[cName] = [nodeIndex]
            else:
                nameDict[cName].append(nodeIndex)

        # Now sort subtrees with common canonical names:
        sorted_trees = []
        for cName in sorted(nameDict.keys()):
            # Within equal canonincal names sort daughters by the generated subtrees
            sorted_trees += self.sortCommonSubTrees(nameDict[cName])

        return sorted_trees

    def sortCommonSubTrees(self, subtreeList):
        """
        Sorts a list of subtrees of self generated by the nodes
        in subtreeList using a quicksort algorithm.
        All the subtrees should have a common topology
        (same canonical name).

        : param subtreeList: List of node indices

        : return: Sorted list of node indices.
        """

        if len(subtreeList) == 1 or len(subtreeList) == 0:
            return subtreeList

        s = subtreeList[:]
        pivot = s[0]
        i = 0
        for j in range(len(s)-1):
            if self.compareSubTrees(s[j+1], pivot) < 0:
                s[j+1], s[i+1] = s[i+1], s[j+1]
                i += 1
        s[0], s[i] = s[i], s[0]
        first_part = self.sortCommonSubTrees(s[:i])
        second_part = self.sortCommonSubTrees(s[i+1:])
        first_part.append(s[i])

        sortedList = first_part + second_part

        return sortedList

    def compareSubTrees(self, n1, n2):
        """
        Compare the subtrees generated by the nodes n1 and n2.

        : param n1: Node index for the root of subtree1
        : param n2: Node index for the root of subtree2

        : return: 0, if subtrees are equal, -1 if subtree1 < subtree2, 1 if subtree1 > subtree2
        """

        root1 = self.indexToNode(n1)
        root2 = self.indexToNode(n2)
        cmp = root1.compareTo(root2)
        if cmp != 0:
            return cmp

        # For inclusive nodes always return True (once nodes are equal)
        if root1.isInclusive or root2.isInclusive:
            return 0

        daughters1 = self.daughterIndices(n1)
        daughters2 = self.daughterIndices(n2)
        # If nodes are leaves, return 0
        if len(daughters1) == len(daughters2) == 0:
            return 0

        # Check if the daughters from n2 match the ones from n1:
        # (the daughters should be sorted at this point)
        for i1, d1 in enumerate(daughters1):
            d2 = daughters2[i1]
            cmp = self.compareSubTrees(d1, d2)
            if cmp != 0:
                return cmp
        return 0

    def compressToFinalStates(self):
        """
        Compress the SMS to its final states. After the compression
        the tree will have one root(PV). The root's daughters
        are the final state nodes of self.

        : returns: compressed copy of the Tree.
        """

        newTree = self.copy()
        # Get root:
        root = newTree.root
        # Get final state nodes
        fsNodes = [self.indexToNode(n) for n in self.nodeIndices if
                    self.out_degree(n) == 0]

        # Remove all nodes
        newTree.clear()
        # Add root and final state nodes
        rootIndex = newTree.add_node(root)
        fsIndices = newTree.add_nodes_from(fsNodes)
        # Add root > fsNode edges:
        edges = product([rootIndex],fsIndices)
        newTree.add_edges_from(edges)
        newTree._canonName = newTree.getCanonName()
        newTree.sort()

        return newTree


