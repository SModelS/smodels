"""
.. module:: tree
   :synopsis: This is a class for describing Simplified Model Topologies
              used for decomposing BSM models.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>

"""


from smodels.experiment.exceptions import SModelSExperimentError as SModelSError
from smodels.theory.particleNode import ParticleNode,InclusiveParticleNode
from smodels.tools.genericSMS import GenericSMS
from smodels.experiment.expAuxiliaryFuncs import bracketToProcessStr
from itertools import product
from smodels.tools.physicsUnits import fb
from collections import OrderedDict

class ExpSMS(GenericSMS):
    """
    A class for describing Simplified Model Topologies generated by the decompostion
    of full BSM models.
    """

    def __init__(self):
        """
        Initialize basic attributes.
        """

        GenericSMS.__init__(self)

    @classmethod
    def from_string(cls, stringSMS, finalState=None,
                     intermediateState=None, model=None):
        """
        Converts a string describing an SMS to a SMS object. It accepts
        the (old) bracket notation or the process notation. For the old notation the
        optional arguments finalState and intermediateState can also be defined.
        If the argument model is defined, the particle labels will be converted to
        Particle objects from the model. Otherwise the nodes will hold the particle strings.

        :param stringSMS: The process in string format
                              (e.g. '(PV > gluino(1),squark(2)), (gluino(1) >
                               MET,jet,jet), (squark(2) > HSCP,u)' or [[['jet','jet']],[['u']]]).
                               The particle labels should match the particles in the Model
                               (if Model != None).
        :parameter model: The model (Model object) to be used when converting particle labels to
                          particle objects. If None, the nodes will only store the particle labels.
        :parameter finalState: (optional) list containing the final state labels for each branch
                               (e.g. ['MET', 'HSCP'] or ['MET','MET'])
        :parameter intermediateState: (optional) nested list containing intermediate state labels
                                         for each branch  (e.g. [['gluino'], ['gluino']])
        """

        # First check if string is in old format:
        if '[' in stringSMS and ']' in stringSMS:
            procString = bracketToProcessStr(stringSMS, finalState=finalState,
                                             intermediateState=intermediateState)
        elif '>' in stringSMS and 'PV' in stringSMS:
            procString = stringSMS
        else:
            raise SModelSError("Could not recognize string format for element (%s)" % stringSMS)

        decays = procString.replace(" ", "").split("),(")
        decays[0] = decays[0][1:]  # Remove trailing parenthesis
        decays[-1] = decays[-1][:-1]  # Remove remaining parenthesis

        # Split decays into mother and daughters tuples:
        decayParticles = []
        for dec in decays:
            momStr = dec.split('>')[0].strip()
            daughtersStr = [p.strip() for p in dec.split('>')[1].split(',')]
            decayParticles.append((momStr,daughtersStr))

        # Build a mapping (particle string > nodeIndex) for all unstable particles:
        nodesDict = {}
        maxNode = 0
        for mom,daughters in decayParticles:
            if mom == 'PV':
                nodeIndex = 0  # PV is always node zero
            elif '(' in mom and ')' in mom:  # Unstable particles should always have a unique numbering
                nodeIndex = eval(mom.split('(')[1].split(')')[0])
            else:
                continue  # Stable particles will have their nodes defined later
            nodesDict[mom] = nodeIndex
            maxNode = max(maxNode,nodeIndex)  # Store highest node index

        # Make sure particles have unique nodes:
        if len(set(list(nodesDict.values()))) != len(list(nodesDict.values())):
            raise SModelSError("Input string has non unique nodes: %s" % nodesDict)

        # Add the stable particles to nodesDict
        # and create successors dict
        successorsStr = {}
        for mom,daughters in decayParticles:
            successorsStr[mom] = []
            for ptc in daughters:
                if ptc in nodesDict:
                    successorsStr[mom].append(ptc)
                    continue
                maxNode = maxNode+1
                # Enumerate the unstable daughter labels, so they are unique
                ptcLabel = '%s(%i)' %(ptc,maxNode)
                nodesDict[ptcLabel] = maxNode
                successorsStr[mom].append(ptcLabel)


        # Sort successors according to the node index
        sortedMoms = sorted(successorsStr.keys(), key = lambda momStr : nodesDict[momStr])
        sortedSuccessors = OrderedDict()
        for mom in sortedMoms:
            sortedDaughters = sorted(successorsStr[mom], key = lambda dStr : nodesDict[dStr])
            sortedSuccessors[mom] = sortedDaughters

        # Convert strings to node objects:
        for ptcStr in nodesDict:
            # Check for inclusive node
            # (in this case, the daughters have to be included as final states of the node)
            label = ptcStr.split('(')[0]
            if label.lower() == 'inclusivenode':
                node = InclusiveParticleNode()
                if ptcStr in sortedSuccessors:
                    daughters = [dStr.split('(')[0]
                                 for dStr in sortedSuccessors[ptcStr]]
                else:
                    daughters = []
                if model is not None:
                    daughters= [model.getParticle(label=d) for d in daughters[:]]
                node.finalStates = sorted(daughters)
                # Delede daughters:
                sortedSuccessors[ptcStr] = []
            else:
                if model is not None:
                    particle = model.getParticle(label=label)
                    node = ParticleNode(particle=particle)
                else:
                    node = ParticleNode(particle=label)

            # Change key from node index to node object
            nodesDict[ptcStr] = node

        # Create SMS, add all unstable nodes following the sorted order
        # and keep track of generated indices
        newSMS = cls()
        smsDict = {}
        for momStr in sortedSuccessors:
            nodeIndex = newSMS.add_node(nodesDict[momStr])
            smsDict[momStr] = nodeIndex
        # Add stable nodes and keep track of SMS indices
        for ptcStr in nodesDict:
            if ptcStr in smsDict:
                continue  # Node has been added
            nodeIndex = newSMS.add_node(nodesDict[ptcStr])
            smsDict[ptcStr] = nodeIndex

        # Finally add all edges according to successorsDict:
        for momStr, daughtersStr in sortedSuccessors.items():
            if not daughtersStr:
                continue
            momIndex = smsDict[momStr]
            daughterIndices = [smsDict[d] for d in daughtersStr]
            newSMS.add_edges_from(product([momIndex],daughterIndices))

        return newSMS

    def __eq__(self, other):
        """
        SMS equality based on the compareTo method.

        :parameter other: TheorySMS object

        :return: True if objects are equivalent.
        """

        cmp = self.matchesTo(other)

        return (cmp == 0)

    def matchesTo(self, other):
        """
        Compare self to other.
        If the SMS are not sorted, sort them and then do a direct comparison of each
        node with the same nodeIndex.

        :param other: TheorySMS object to be compared against self

        :return: 0, if objects are equal, -1 if self < other, 1 if other > sekf
        """

        if not isinstance(other,GenericSMS):
            raise SModelSError("Can not compare ExpSMS and %s" %str(type(other)))

        # IMPLEMENT MATCHING


