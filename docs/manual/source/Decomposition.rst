.. index:: Decomposition into Simplified Models

.. |invisible compression| replace:: :ref:`invisible compression <invComp>`
.. |mass compression| replace:: :ref:`mass compression <massComp>`
.. |SMS| replace:: :ref:`SMS <SMS>`
.. |SMS topology| replace:: :ref:`SMS topology <SMS>`
.. |SMS topologies| replace:: :ref:`SMS topologies <SMS>`
.. |decomposition| replace:: :doc:`decomposition <Decomposition>`
.. |theory predictions| replace:: :doc:`theory predictions <TheoryPredictions>`
.. |theory prediction| replace:: :doc:`theory prediction <TheoryPredictions>`
.. |constraint| replace:: :ref:`constraint <ULconstraint>`
.. |constraints| replace:: :ref:`constraints <ULconstraint>`
.. |particle| replace:: :ref:`particle <particleClass>`
.. |particles| replace:: :ref:`particles <particleClass>`

.. _decomposition:

Decomposition into Simplified Models
====================================

Given an input model (see :doc:`Basic Input <BasicInput>`), the first task of SModelS is to decompose
the full model into a sum of Simplified Models (|SMS|).

.. _decomp:

Decomposition
-------------

The input model stores information about  the masses of all
the BSM states as well as their production cross sections, decay branching ratios and total widths.
All the cross sections for the *BSM particles* serve as the initial step for the decomposition.
Starting from these primary mothers ("A" and "B" in :numref:`Fig. %s <decomp1>`), all the possible decays are generated
according to the decay information for each mother particle. This procedure is represented in :numref:`Fig. %s <decomp1>`.

.. _decomp1:

.. figure:: images/decomp1C.png
   :width: 75%
   :align: center

   First step of decomposition. The BSM particles produced in the hard scattering (primary vertex) and their decays are used as the initial step for constructing the |SMS topologies|.

After the first step shown in :numref:`Fig. %s <decomp1>`, the *unstable* BSM particles appearing at the end of the cascade decays are defined as the "new mothers" and new |SMS topologies| are generated using their decays, as illustrated in :numref:`Fig. %s <decomp2>`. 


.. _decomp2:

.. figure:: images/decomp2C.png
   :width: 75%
   :align: center

   Schematic representation of the subsequent decomposition steps used to build the final |SMS topologies|.

These procedure is repeated until all unstable BSM particles appearing in the |SMS| have decayed. 
Stable are those without decay channels or with a total decay width smaller than some maximal value (set by :ref:`stableWidth in the parameters file <parameterFileModel>`).
In order to describe |SMS topologies| with meta-stable particles appearing as final states (relevant for long-lived particle searches), these are defined as BSM states with a total width (:math:`\Gamma`) in the interval:

.. math::

   \Gamma_{\mbox{stable}} < \Gamma < \Gamma_{\mbox{prompt}}

where :math:`\Gamma_{\mbox{stable}}` and :math:`\Gamma_{\mbox{prompt}}` are set by the user (see :ref:`parameters file <parameterFileModel>`). If a meta-stable particle appears in a cascade decay, the decomposition will generate a |SMS topology| where it appears as a final state *in addition* to the |SMS topologies| where the meta-stable particle has decayed, as illustrated in :numref:`Fig. %s <metastable>`. The values of :math:`\Gamma_{\mbox{stable}}` and :math:`\Gamma_{\mbox{prompt}}` should be carefully chosen by the user, since they are used to define the prompt, meta-stable and stable decay regimes.

.. _metastable:

.. figure:: images/metastable.png
   :width: 65%
   :align: center

   Example of how the decomposition procedure handles the decays of BSM particles with different lifetimes (or total width).

For each of the |SMS topologies| generated by the decomposition procedure, a *weight* is defined as the product of the hard scattering cross section times all the branching ratios appearing in the cascade decays.
In order to avoid a too large number of topologies, only those satisfying a :ref:`minimum weight <minweight>` requirement are kept.
Furthermore, the |SMS| are grouped according to their structure (or :ref:`canonical name <canonicalName>`). The final output of the
decomposition is a dictionary mapping each :ref:`canonical name <canonicalName>` to a list of |SMS topologies| sharing a common structure.

* **The decomposition is implemented by the** `decompose method <decomposition.html#decomposition.decomposer.decompose>`_.


.. _minweight:

Minimum Decomposition Weight
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some models may contain a large number of new states and each may have a large number of possible decays.
As a result, long cascade decays are possible and the number of elements generated by the decomposition process
may become too large, and the computing time too long.
For most practical purposes, however, elements with extremely small weights (cross section times BRs)
can be discarded, since they will fall well below the experimental limits. Therefore, during the decomposition,
whenever an element is generated with a weight below some minimum value, this element (and all elements derived from it) is ignored.
The minimum weight to be considered is set by the :ref:`sigmacut parameter in the parameters file <parameterFileSigmacut>`
and is easily adjustable (see `decomposer.decompose <theory.html#theory.decomposer.decompose>`_).

Note that, when computing the |theory predictions|, the weight of several |elements| can be combined together. Hence
it is recommended to set the value of :ref:`sigmacut <parameterFileSigmacut>`
approximately one order of magnitude below the minimum signal cross sections the experimental data can constrain.


.. _elementComp:

Compression of Elements
-----------------------


During the decomposition process it is possible to perform several simplifications on
the :ref:`elements <element>` generated. Two useful
simplifications are possible: :ref:`Mass Compression <massComp>` and :ref:`Invisible Compression <invComp>`.
The main advantage of performing these compressions is that the simplified :ref:`element <element>` is
always shorter (has fewer cascade decay steps), which makes it more likely to be constrained by experimental
results. The details behind the compression methods are as follows:

.. _massComp:

Mass Compression
^^^^^^^^^^^^^^^^

In case of small mass differences, the *prompt* decay [#]_ of a BSM |particle| to a nearly degenerate
one will in most cases produce soft final states, which can not be experimentally detected.
Consequently, it is a good approximation to neglect the soft final states and *compress* the respective
decay, as shown below:

.. _massCompfig:

.. image:: images/massCompB.png
   :width: 80%

After the compression, only the lightest of the two near-degenerate masses are kept in the element, as shown :ref:`above <massCompfig>`.
The main parameter which controls the compression is :ref:`minmassgap <parameterFileMinmassgap>`,
which corresponds to the maximum value of :math:`\epsilon`
in the :ref:`figure above <massCompfig>` to which the compression is performed:

.. math::
   & \mbox{if } |M_j - M_{j+1}| < minmassgap \rightarrow \mbox{the *prompt* decay is compressed}\\
   & \mbox{if } |M_j - M_{j+1}| > minmassgap \mbox{ or the decay is not prompt}  \rightarrow \mbox{the decay is NOT compressed}\\

Note that the compression is an approximation since the final
states, depending on the boost of the parent state, may not always be soft.
It is recommended to choose values of :ref:`minmassgap <parameterFileMinmassgap>`
between 1-10 GeV; the default value is 5 GeV.

* **Mass compression is implemented by the** `massCompress <theory.html#theory.element.Element.massCompress>`_ **method**
  and can be easily turned on/off by the :ref:`doCompress parameter in the parameters file <parameterFileDoCompress>`.

.. _invComp:

Invisible Compression
^^^^^^^^^^^^^^^^^^^^^

Another type of compression is possible when the last BSM decay appearing in a :ref:`branch <branch>` is invisible.
The most common example is

.. math::
   A \rightarrow \nu + B

as the last step of the decay chain, where :math:`\nu` is a SM neutrino, :math:`A` is a *neutral particle
and/or decays promptly* and :math:`B` is an invisible particle leading to a MET signature.
Since both the neutrino and
:math:`B` are invisible, for all experimental purposes the effective MET object is :math:`B + \nu = A`.
Hence it is possible to omit the last step in the cascade decay, resulting in a compressed element.
Note that this compression can be applied consecutively to several steps of the cascade decay if all of them
contain only invisible final states:


.. _massInvpfig:

.. image:: images/invCompB.png
   :width: 80%


After the compression, the last BSM state appearing in the compressed |element| is
replaced by an effective |particle| with no electric or color charge, with label "inv" and with the mass of the parent
(:math:`A` in the example above). Furthermore since the original neutral final state (:math:`B`)
can in principle be meta-stable, the new effective final state inherits its width.

* **Invisible compression is implemented by the** `invisibleCompress <theory.html#theory.element.Element.invisibleCompress>`_ **method**
  and can be easily turned on/off by the :ref:`doInvisible parameter in the parameters file <parameterFileDoInvisible>`.


Element Sorting
---------------

In order to improve the code performance, |elements| created during |decomposition| and
sharing a common |topology| are sorted.
Sorting allows for an convenient ordering of the elements belonging to a topology and
faster element comparison.
Elements are sorted according to their branches. Branches are compared according to
the following order of properties:

* Number of vertices
* Number of final states in each vertex
* BSM (Z\ :sub:`2`-odd) particles
* Z\ :sub:`2`-even final state particles in each vertex

Finally, particles are compared according to the following order of properties (if defined):

* Z\ :sub:`2` parity
* Spin
* Color representation
* Electric charge
* Mass
* Total width

As an example, consider the three elements below where all BSM (Z\ :sub:`2`-odd) particles
only differ by their mass:


.. _elementsorting:

.. image:: images/elSorting.png
   :width: 80%

The correct ordering of the above elements is:

Element 3 < Element 2 < Element 1


Element 1 is 'larger' than the other two since it has a larger number of vertices.
Elements 2 and 3  are identical, except for their masses. Since the last BSM particle
appearing in the lower branch of Element 3 has a smaller mass than the corresponding
particle in Element 2, the former is 'smaller' than the latter.
Finally if all the branch features listed above are identical for both branches, the
elements being compared are considered to be equal.
Futhermore, the branches belonging to the same element are also sorted. Hence, if an element
has two branches:

.. math::
   element = [branch1, branch2],

it implies

.. math::
   branch1 < branch2

regarding their ordering.




* **Branch sorting is implemented by the** `sortBranches <theory.html#theory.element.Element.sortBranches>`_ **method**




Within SModelS, |SMS| are grouped according to their
canonical name. A topology dictionary is constructed mapping the canonical names to a list of |SMS| sharing a common graph structure, as represented below:

.. _topoDict:

.. figure:: images/topologyDict.png
   :width: 90%
   :align: center
   
   Example of how the |SMS topologies| are grouped in the topology dictionary after decomposition.

* **Topology dictionaries are described by the** `TopologyDict Class <decomposition.html#decomposition.topologyDict.TopologyDict>`_


.. [#] Decays of meta-stable particles should not be compressed, even if soft, since they might result in
       distinct signatures depending on the quantum numbers of the decaying particle. Particles are assumed
       to be meta-stable if their width is below the value set by the :ref:`promptWidth parameter <parameterFileModel>`.
